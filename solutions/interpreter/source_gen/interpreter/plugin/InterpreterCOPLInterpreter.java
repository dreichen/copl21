package interpreter.plugin;

/*Generated by MPS */

import com.mbeddr.mpsutil.interpreter.rt.InterpreterBase;
import java.util.List;
import com.mbeddr.mpsutil.interpreter.rt.IEvaluator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.mbeddr.mpsutil.interpreter.rt.ConceptEvaluatorBase;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.interpreter.rt.IContext;
import com.mbeddr.mpsutil.interpreter.rt.ICoverageAnalyzer;
import com.mbeddr.mpsutil.interpreter.rt.ComputationTrace;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.mbeddr.mpsutil.interpreter.rt.StopAndReturnException;
import com.mbeddr.mpsutil.interpreter.rt.InterpreterEscapeException;
import com.mbeddr.mpsutil.interpreter.rt.InterpreterRuntimeException;
import com.mbeddr.mpsutil.interpreter.rt.EvaluatorInfo;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import com.mbeddr.mpsutil.interpreter.rt.ITypeMapper;
import com.mbeddr.mpsutil.interpreter.rt.IRelationship;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;

public class InterpreterCOPLInterpreter extends InterpreterBase {
  public InterpreterCOPLInterpreter() {
    init();
  }

  protected void populateEvaluators(List<? extends IEvaluator> evaluators) {
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.Addition$PJ, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/2530598663949869233", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          return EvalHelper.evalInt(SLinkOperations.getTarget(node, LINKS.left$XEZB)) + EvalHelper.evalInt(SLinkOperations.getTarget(node, LINKS.right$XFtD));
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("+()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("Addition");
      }

      @Override
      public String toString() {
        return "Addition";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.Division$fm, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/2530598663949963303", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          return Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.left$XEZB))) / Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.right$XFtD)));
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("/()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("Division");
      }

      @Override
      public String toString() {
        return "Division";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.Multiplication$Rc, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/2530598663949973064", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          return Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.left$XEZB))) * Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.right$XFtD)));
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("*()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("Multiplication");
      }

      @Override
      public String toString() {
        return "Multiplication";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.Substraction$Oi, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/2530598663950023153", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          return Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.left$XEZB))) - Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.right$XFtD)));
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("-()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("Substraction");
      }

      @Override
      public String toString() {
        return "Substraction";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.LessExpression$$9, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/1928515635053624997", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          return Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.left$XEZB))) < Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.right$XFtD)));
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("<()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("LessExpression");
      }

      @Override
      public String toString() {
        return "LessExpression";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.GreaterExpression$JL, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/1928515635053644078", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          return Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.left$XEZB))) > Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.right$XFtD)));
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException(">()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("GreaterExpression");
      }

      @Override
      public String toString() {
        return "GreaterExpression";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.UnequalExpression$Na, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/1928515635053659770", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          return Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.left$XEZB))) != Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.right$XFtD)));
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("!=()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("UnequalExpression");
      }

      @Override
      public String toString() {
        return "UnequalExpression";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.LessEqualExpression$YM, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/1928515635053675658", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          return Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.left$XEZB))) <= Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.right$XFtD)));
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("<=()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("LessEqualExpression");
      }

      @Override
      public String toString() {
        return "LessEqualExpression";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.GreaterEqualExpression$2b, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/1928515635053682262", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          return Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.left$XEZB))) >= Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.right$XFtD)));
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException(">=()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("GreaterEqualExpression");
      }

      @Override
      public String toString() {
        return "GreaterEqualExpression";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.AndExpression$b8, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/1928515635055488226", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          if (Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.left$XEZB))) > 0) {
            if (Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.right$XFtD))) > 0) {
              return 1;
            }
          }
          return 0;
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("&&()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("AndExpression");
      }

      @Override
      public String toString() {
        return "AndExpression";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.OrExpression$nO, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/1928515635055511878", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          if (Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.left$XEZB))) > 0) {
            return 1;
          }
          if (Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.right$XFtD))) > 0) {
            return 1;
          }
          return 0;
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("||()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("OrExpression");
      }

      @Override
      public String toString() {
        return "OrExpression";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.ParenthesisExpression$$t, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/1610976182721422644", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          return Integer.valueOf(EvalHelper.eval(SLinkOperations.getTarget(node, LINKS.expression$Q6Vt)));
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("ParenthesisExpression()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("ParenthesisExpression");
      }

      @Override
      public String toString() {
        return "ParenthesisExpression";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.IntRef$ty, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/1610976182721463878", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          return Integer.valueOf(SPropertyOperations.getInteger(SLinkOperations.getTarget(node, LINKS.value$pwmv), PROPS.value$D6Nh));
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("IntRef()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("IntRef");
      }

      @Override
      public String toString() {
        return "IntRef";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.IntVal$gW, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/1610976182721471541", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          return Integer.valueOf(SPropertyOperations.getInteger(node, PROPS.value$QidL));
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("IntVal()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("IntVal");
      }

      @Override
      public String toString() {
        return "IntVal";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.BoolVal$rP, "r:7adc6d04-8e3f-4e39-821a-acd3f37b96c5(interpreter.plugin)/1928515635055460309", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          if (SPropertyOperations.getBoolean(node, PROPS.value$$s_A)) {
            return 1;
          }
          return 0;
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("BoolVal()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("BoolVal");
      }

      @Override
      public String toString() {
        return "BoolVal";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
  }


  protected void populateTypeMappers(List<? extends ITypeMapper> typeMappers) {
  }



  protected void populateRelationships(List<? extends IRelationship> relationships) {
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink left$XEZB = MetaAdapterFactory.getContainmentLink(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x231e7e13c1c9328fL, 0x6b55ca2b4354d18L, "left");
    /*package*/ static final SContainmentLink right$XFtD = MetaAdapterFactory.getContainmentLink(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x231e7e13c1c9328fL, 0x6b55ca2b4354d1aL, "right");
    /*package*/ static final SContainmentLink expression$Q6Vt = MetaAdapterFactory.getContainmentLink(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x165b564d88b1d2d9L, 0x165b564d88b1d4abL, "expression");
    /*package*/ static final SReferenceLink value$pwmv = MetaAdapterFactory.getReferenceLink(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x107296237e2a2b36L, 0x6b55ca2b438e85dL, "value");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Addition$PJ = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x231e7e13c1c93295L, "SoSeL21.structure.Addition");
    /*package*/ static final SConcept Division$fm = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x231e7e13c1ca862eL, "SoSeL21.structure.Division");
    /*package*/ static final SConcept Multiplication$Rc = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x231e7e13c1c93298L, "SoSeL21.structure.Multiplication");
    /*package*/ static final SConcept Substraction$Oi = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x231e7e13c1c93292L, "SoSeL21.structure.Substraction");
    /*package*/ static final SConcept LessExpression$$9 = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x1ac376c09b284620L, "SoSeL21.structure.LessExpression");
    /*package*/ static final SConcept GreaterExpression$JL = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x1ac376c09b284623L, "SoSeL21.structure.GreaterExpression");
    /*package*/ static final SConcept UnequalExpression$Na = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x1ac376c09b28462aL, "SoSeL21.structure.UnequalExpression");
    /*package*/ static final SConcept LessEqualExpression$YM = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x1ac376c09b28462dL, "SoSeL21.structure.LessEqualExpression");
    /*package*/ static final SConcept GreaterEqualExpression$2b = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x1ac376c09b284634L, "SoSeL21.structure.GreaterEqualExpression");
    /*package*/ static final SConcept AndExpression$b8 = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x1ac376c09b44d871L, "SoSeL21.structure.AndExpression");
    /*package*/ static final SConcept OrExpression$nO = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x1ac376c09b4533caL, "SoSeL21.structure.OrExpression");
    /*package*/ static final SConcept ParenthesisExpression$$t = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x165b564d88b1d2d9L, "SoSeL21.structure.ParenthesisExpression");
    /*package*/ static final SConcept IntRef$ty = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x107296237e2a2b36L, "SoSeL21.structure.IntRef");
    /*package*/ static final SConcept IntVal$gW = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x107296237e2a2b31L, "SoSeL21.structure.IntVal");
    /*package*/ static final SConcept BoolVal$rP = MetaAdapterFactory.getConcept(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x1ac376c09b42a6a9L, "SoSeL21.structure.BoolVal");
  }

  private static final class PROPS {
    /*package*/ static final SProperty value$D6Nh = MetaAdapterFactory.getProperty(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x1b9b1aa24ca9280bL, 0x1b9b1aa24ca9280eL, "value");
    /*package*/ static final SProperty value$QidL = MetaAdapterFactory.getProperty(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x107296237e2a2b31L, 0x107296237e2a2b34L, "value");
    /*package*/ static final SProperty value$$s_A = MetaAdapterFactory.getProperty(0x7e642a5f6d9b49f5L, 0x815956089ac1a1e9L, 0x1ac376c09b42a6a9L, 0x1ac376c09b42a6acL, "value");
  }
}
